"use client";
import { normalizeExternalMaterials, looksLikeExternalMaterials } from "@/app/lib/materials-normalize";
import { useEffect, useMemo, useState } from "react";

type Size = { w:number; l:number; supplier?:string; usdPerTon?:number|null; preferred?:boolean };
type Gram = { grams:number[]; sizes: Size[]; indexHint?: number|null };
type MatType = { name:string; grams: Gram[]; _edit?:boolean; _snapshot?:MatType };

function clone<T>(x:T):T { return JSON.parse(JSON.stringify(x)); }

export default function MaterialsPage(){
  const [items, setItems] = useState<MatType[]>([]);
  const [dirty, setDirty] = useState(false);
  const [msg, setMsg] = useState("");

  // Carga inicial (si tu API existe, mantener; si no, ignora errores)
  useEffect(()=>{(async()=>{
    try{
      const r = await fetch("/api/admin/materials");
      if(!r.ok) return;
      const j = await r.json();
      const arr = Array.isArray(j?.items) ? j.items : [];
      if (arr.length){ setItems(arr as MatType[]); }
    }catch{}
  })()},[]);

  // === Importador robusto: acepta tu JSON externo y el interno ===
  async function handleImport(e:any){
    const f = e.currentTarget?.files?.[0];
    if(!f) return;
    try{
      const txt = await f.text();
      const raw = JSON.parse(txt);
      let imported:any[] = [];

      if (looksLikeExternalMaterials(raw)) {
        imported = normalizeExternalMaterials(raw); // priceIndex -> usdPerTon, stocked -> preferred
      } else if (Array.isArray((raw as any)?.items)) {
        imported = (raw as any).items; // formato interno
      } else if (Array.isArray(raw)) {
        imported = raw; // ya normalizado
      } else {
        throw new Error("Estructura no reconocida");
      }

      setItems((imported as MatType[]).map(t=>({...t, _edit:false, _snapshot:undefined})));
      setDirty(true); setMsg(`Importados ${imported.length} tipos (sin guardar)`);
    } catch(err:any){
      alert("No se pudo importar el JSON: " + (err?.message || "error"));
    }
    try { e.currentTarget.value = ""; } catch {}
  }

  function addType(){
    setItems(p=>[ { name:"Nuevo tipo", grams:[{ grams:[80], sizes:[] }], _edit:true }, ...p ]);
    setDirty(true);
  }
  function startEdit(ix:number){ setItems(p=>p.map((t,i)=> i===ix ? ({...t, _edit:true, _snapshot:clone(t)}) : t)); }
  function cancelEdit(ix:number){ setItems(p=>p.map((t,i)=> i===ix ? (t._snapshot ? {...t._snapshot, _edit:false, _snapshot:undefined} : {...t, _edit:false}) : t)); }
  function saveEdit(ix:number){ setItems(p=>p.map((t,i)=> i===ix ? ({...t, _edit:false, _snapshot:undefined}) : t)); }
  function rmType(ix:number){
    if(!confirm("Â¿Eliminar este tipo de papel y todos sus gramajes?")) return;
    setItems(p=>p.filter((_,i)=>i!==ix)); setDirty(true);
  }

  async function saveAll(){
    setMsg("Guardando");
    try{
      const payload = { items: items.map(({_edit,_snapshot, ...t})=>t) };
      const r = await fetch("/api/admin/materials", { method:"PUT", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(payload) });
      if (!r.ok){ const j = await r.json().catch(()=>null); throw new Error(j?.error || "fallÃ³ el guardado"); }
      setDirty(false); setMsg("Guardado OK");
    }catch(e:any){ setMsg("No se pudo guardar: "+(e?.message||"error")); }
  }

  return (
    <div className="space-y-5">
      <header className="flex flex-wrap items-center gap-3">
        <a href="/admin" className="btn btn-ghost gap-2"> Volver</a>
        <h1 className="text-2xl font-bold">Materiales</h1>
        <input type="file" accept="application/json" onChange={handleImport} />
        <button className="px-3 py-2 rounded bg-white text-black" onClick={addType}>Agregar tipo</button>
        <button className="px-3 py-2 rounded bg-white text-black" onClick={saveAll} disabled={!dirty}>Guardar todo</button>
        <span className="opacity-80">{msg}</span>
      </header>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {items.map((t,ix)=>(
          <div key={ix} className="rounded-xl border p-4 space-y-3">
            <div className="flex items-center gap-2">
              {t._edit
                ? <input className="px-2 py-1 rounded bg-white/10 border" value={t.name} onChange={e=>{const v=e.target.value; setItems(p=>p.map((x,i)=>i===ix?{...x,name:v}:x)); setDirty(true);}} />
                : <h2 className="font-semibold">{t.name}</h2>
              }
              <div className="ml-auto flex gap-2">
                {!t._edit && <button className="px-2 py-1 border rounded" onClick={()=>startEdit(ix)}>âœï¸</button>}
                {t._edit && <>
                  <button className="px-2 py-1 border rounded" onClick={()=>saveEdit(ix)}>â¬†ï¸</button>
                  <button className="px-2 py-1 border rounded" onClick={()=>cancelEdit(ix)}>ðŸ”„</button>
                  <button className="px-2 py-1 border rounded" onClick={()=>rmType(ix)}>ðŸ—‘ï¸</button>
                </>}
              </div>
            </div>

            {(t.grams||[]).map((g, gx)=>(
              <div key={gx} className="rounded-md bg-white/5 p-3">
                <div className="text-sm opacity-80">Gramajes: {(g.grams||[]).join(", ")}</div>
                <div className="mt-2 space-y-1">
                  {(g.sizes||[]).map((s, sx)=>(
                    <div key={sx} className="text-sm">
                      {s.w} Ã— {s.l} â€” {s.supplier||"Proveedor?"} â€” {s.usdPerTon!=null?`USD/Ton ${s.usdPerTon}`:"USD/Ton?"} {s.preferred?"(preferido)":""}
                    </div>
                  ))}
                  {(!g.sizes || g.sizes.length===0) && <div className="text-sm opacity-70">Sin tamaÃ±os cargados.</div>}
                </div>
              </div>
            ))}
          </div>
        ))}
      </div>
    </div>
  );
}

